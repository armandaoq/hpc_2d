import numpy as np


def inverse(a):
    """Compute the inverse of matrix a mod 2"""
    n = a.shape[0]
    ai = np.hstack((np.copy(a), np.identity(n).astype(int)))
    for i in range(n):
        if ai[i, i] == 0:
            h = i + 1
            while ai[h, i] != 1:
                h = h + 1
            ai[[h, i]] = ai[[i, h]]  # swap
        for h in range(n):
            if h == i:
                continue
            if ai[h, i] == 1:
                ai[h, :] = (ai[i, :] + ai[h, :]) % 2
    assert np.array_equal(
        (ai[:, n:] @ a) % 2, np.identity(n, dtype=int)
    ), "Error in inverse computation"
    return ai[:, n:]


def gaussian_reduction(b):
    """Uses gauss elimination to compute the spaces generated by a matrix over GF(2)\
    outputs: rank, a matrix whose rows are a basis of the kernel\
    a matrix of independent rows of b, which generate its image\
    a matrix of independent rows, that complete the rows of gauss['im']\
    to a basis of the space\
     the set of pivot row: indices of maximal set of independent row for b"""
    a = np.copy(b)
    m, n = a.shape
    ker = np.eye(n).astype(int)
    pivot = set()
    pivot_row = set()
    for j in range(n):
        i = 0
        while a[i][j] != 1 and i < m - 1:
            i += 1
        if a[i][j] == 1:
            pivot.add(j)
            pivot_row.add(i)
            for k in range(j + 1, n):
                if a[i][k] == 1:
                    a[:, k] = (a[:, j] + a[:, k]) % 2
                    ker[:, k] = (ker[:, j] + ker[:, k]) % 2
    indices = [j for j in range(n) if j not in pivot]
    ker = (ker[:, indices]).T
    rk = len(pivot)
    image = b[list(pivot_row), :]
    complete_to_basis = np.eye(n).astype(int)[indices, :]
    return {
        "rank": rk,
        "ker": ker,
        "im": image,
        "complete_to_basis": complete_to_basis,
        "pivot_row": pivot_row,
        "indices": indices,
    }


def rank(a):
    return gaussian_reduction(a)["rank"]


def find_span(a, span=None):
    """Outputs the row span of a."""
    if span is None:
        span = []
    m = a.shape[0]
    if m == 0:
        return span
    else:
        temp = [a[0]]
        for v in span:
            temp.append((a[0] + v) % 2)
        span = span + temp
        span = list(np.unique(span, axis=0))
        return find_span(a[1:, :], span)


def projection(b):
    """ "find Pi: C_n --> C_n s.t. Pi^2 = Pi and Im(Pi) = row_span(b)"""
    gauss = gaussian_reduction(b)
    n = b.shape[1]
    k = gauss["rank"]
    m = np.vstack((gauss["im"], gauss["complete_to_basis"])).T
    inv_m = inverse(m)
    pi = np.identity(n).astype(int)
    pi[:, k:n] = np.zeros([n, n - k]).astype(int)
    pi_canonical = (m @ pi @ inv_m) % 2
    return pi_canonical


def from_row_im_to_ker(b):
    """

    :param b:
    :return: a matrix whose ker is the row image of b
    """
    # row image of matrix is now ker
    gauss = gaussian_reduction(b)
    m = np.vstack((gauss["im"], gauss["complete_to_basis"])).T
    inv_m = inverse(m)
    rank_b = gauss["rank"]
    pi = np.identity(m.shape[0]).astype(int)
    pi[:, 0:rank_b] = np.zeros([m.shape[0], rank_b]).astype(int)
    pi_canonical = (m @ pi @ inv_m) % 2
    assert not (pi_canonical @ gauss["im"].T % 2).any()
    return pi_canonical


def get_support(m):
    """
    A matrix, print support as pair
    :param m:
    :return:
    """
    indices = m.nonzero()
    if len(indices) == 2:
        rows, cols = indices
        out = [(rows[i], cols[i]) for i in range(len(rows))]
    else:
        rows = indices[0]
        out = [rows[i] for i in range(len(rows))]
    return out
